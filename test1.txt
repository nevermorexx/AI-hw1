--000--,--0X0--,000X000,0000ÃŸ000,0000000,--000--,--000--
for row in range(7):
        for col in range(7):
            if pegSolitaireObject.gameState[row][col] == 1:
                oldPos = (row, col)
                for direction in directionSets:
                    if pegSolitaireObject.is_validMove(oldPos, direction):
                        while (not pegSolitaireObject.reachDestination()):
                            pegSolitaireObject.getNextState(oldPos, direction)
                            if pegSolitaireObject.reachDestination():
                                return True
                            else:
                                ItrDeepSearch(pegSolitaireObject)
                    else:
                        pass

    if row == 6 and col == 6 and (not pegSolitaireObject.reachDestination()):
        # when reached the last node, and did all the possible iterations,
        # but the goal is not reached, suggest no solution
        if (len(pegSolitaireObject.trace) == 0):
            print "no solution to find the goal"


        # when reached the last node, but didn't reach the goal, and the trace list is not empty
        # trace back the last move and keep searching
        else:
            # the last move recorded in the trace
            newPos = pegSolitaireObject.trace[len(pegSolitaireObject.trace) - 1]
            oldPos = pegSolitaireObject.traceBack()
            oldDirection = ((newPos[0] - oldPos[0]) / 2, (newPos[1] - oldPos[1]) / 2)

            # trace back the node, but keep searching the same node with different untested directions
            for oldDirectionIndex in range(4):
                if cmp(oldDirection, directionSets[oldDirectionIndex]) == 1:
                    break

            if oldDirectionIndex < 3:
                for currentDirectionIndex in range(oldDirectionIndex+1, 4):
                    currentDirection = directionSets[currentDirectionIndex]
                    if pegSolitaireObject.is_validMove(oldPos, currentDirection):
                        while (not pegSolitaireObject.reachDestination()):
                            pegSolitaireObject.getNextState(oldPos, currentDirection)
                            print 'node %d,%d is added to trace' %(oldPos[0],oldPos[1])
                            if pegSolitaireObject.reachDestination():
                                return True
                            else:
                                ItrDeepSearch(pegSolitaireObject)

            # trace back the oldPos and keep searching the remaining nodes
            for i in range(oldPos[0], 7):
                for j in range(0, 7):
                    if i == oldPos[0] and j <= oldPos[1]:
                        pass
                    else:
                        if pegSolitaireObject.gameState[i][j] == 1:
                            oldPos = (i, j)
                            for direction in directionSets:
                                if pegSolitaireObject.is_validMove(oldPos, direction):
                                    while (not pegSolitaireObject.reachDestination()):
                                        pegSolitaireObject.getNextState(oldPos, direction)
                                        if pegSolitaireObject.reachDestination():
                                            return True
                                        else:
                                            ItrDeepSearch(pegSolitaireObject)